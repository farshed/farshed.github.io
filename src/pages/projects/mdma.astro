---
import Raw from '../../layouts/Raw.astro';
---

<Raw>
  <div class="h-screen max-w-xl mx-auto py-16">
    <h1 class="text-4xl font-bold mb-8">Title</h1>
    <p>Body</p>
  </div>
</Raw>

<script>
  document.body.contentEditable = 'true';
  document.designMode = 'on';

  const elem = {
    '#': 'h1',
    '##': 'h2',
    '###': 'h3',
    '####': 'h4',
    '#####': 'h5'
  };

  // mdLineToHtml: parse ONE markdown line -> simple html
  function mdLineToHtml(line) {
    if (line == null) return '';

    // 1) normalize & trim right (don't kill leading spaces that may matter)
    line = String(line).replace(/\r?\n$/, '');

    // 2) helpers
    const esc = (s) =>
      s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

    // 3) classify block type (headings, hr, quote, lists)
    const hrRe = /^(?:\s*)(?:([-_*])\s*\1\s*\1(?:\s*\1)*)\s*$/; // --- *** ___ etc
    const headingRe = /^(#{1,6})[ \t]+(.+?)\s*$/;
    const bqRe = /^\s*>\s?(.*)$/;
    const olRe = /^\s{0,3}(\d+)[.)][ \t]+(.+?)\s*$/;
    const ulRe = /^\s{0,3}([*+\-])[ \t]+(.+?)\s*$/;

    // 4) inline processing — do on the content portion only
    function inline(md) {
      if (!md) return '';

      // protect code spans with sentinels
      const codeSpans = [];
      md = md.replace(/`([^`]+)`/g, (_, code) => {
        codeSpans.push(code);
        return `\u0000CODE${codeSpans.length - 1}\u0000`;
      });

      // images ![alt](src "title")
      md = md.replace(/!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)/g, (_, alt, src, title) => {
        const a = esc(alt || '');
        const s = esc(src);
        const t = title ? ` title="${esc(title)}"` : '';
        return `<img src="${s}" alt="${a}"${t}>`;
      });

      // links [text](href "title")
      md = md.replace(/\[([^\]]+)\]\(([^)\s]+)(?:\s+"([^"]*)")?\)/g, (_, txt, href, title) => {
        const h = esc(href);
        const t = title ? ` title="${esc(title)}"` : '';
        return `<a href="${h}"${t}>${inline(txt)}</a>`;
      });

      // bold-italic (*** / ___)
      md = md
        .replace(/\*\*\*([^\*]+)\*\*\*/g, '<strong><em>$1</em></strong>')
        .replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>');

      // bold (** / __)
      md = md
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/__([^_]+)__/g, '<strong>$1</strong>');

      // italics (* / _) — avoid touching bold markers
      md = md
        .replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>')
        .replace(/(?<!_)_([^_]+)_(?!_)/g, '<em>$1</em>');

      // strikethrough
      md = md.replace(/~~([^~]+)~~/g, '<del>$1</del>');

      // escape remaining raw html-ish chars
      md = md
        .split(/(<(?:img|a)\b[^>]*>.*?<\/a>|<img\b[^>]*>)/i) // crude split to not double-escape tags we just made
        .map((chunk, i) => {
          if (i % 2 === 1) return chunk; // skip escaping our own tags
          return esc(chunk);
        })
        .join('');

      // restore code spans (escaped content inside <code>)
      md = md.replace(/\u0000CODE(\d+)\u0000/g, (_, i) => `<code>${esc(codeSpans[+i])}</code>`);

      return md;
    }

    // 5) blocks
    if (hrRe.test(line)) return '<hr>';

    const h = line.match(headingRe);
    if (h) {
      const level = h[1].length;
      return `<h${level}>` + inline(h[2]) + `</h${level}>`;
    }

    const bq = line.match(bqRe);
    if (bq) return `<blockquote>${inline(bq[1])}</blockquote>`;

    const ol = line.match(olRe);
    if (ol) {
      const start = Number(ol[1]);
      // set value attr when not 1 to preserve numbering if you wrap in <ol>
      const valueAttr = start !== 1 ? ` value="${start}"` : '';
      return `<li${valueAttr}>${inline(ol[2])}</li>`;
    }

    const ul = line.match(ulRe);
    if (ul) return `<li>${inline(ul[2])}</li>`;

    // fallback paragraph
    return `<p>${inline(line)}</p>`;
  }
</script>
